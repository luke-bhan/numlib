use uint::construct_uint;

macro_rules! mk_uint {
    ($( $(#[$attr:meta])* $visibility:vis struct $name:ident ( $n_words:tt ); )*) => {
        $(
        construct_uint! {
            $(#[$attr])* $visibility struct $name ( $n_words );
        }
        )*

        enum UInt {
        $(
            $name($name),
        )*
            Multi(Vec<U1024>),
        }

        impl core::fmt::Display for UInt {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                use UInt::*;
                let s = match self {
                $(
                    $name(uint) => uint.to_string(),
                )*
                    Multi(chunks) => {
                        let mut s = String::with_capacity(chunks.len() * 309);
                        for chunk in chunks {
                            s.push_str(&chunk.to_string());
                        }
                        s
                    }
                };
                write!(f, "{}", s)
            }
        }
    }
}

mk_uint! {
    pub struct U256(4);
    pub struct U512(8);
    pub struct U1024(16);
}

/// A `BigInt` stores an arbitrary-length integer.
///
/// At minimum the internal representation of a `BigInt` requires 256 bits. If the integer
/// represented by the `BigInt` can fit in 1024 bits, the `BigInt` will always be allocated on the
/// stack; for anything larger, heap allocations are done. Note that a 1024-bit integer is **very**
/// large -- `2^1024 - 1` consists of 309 digits. This means for most use cases, heap allocation
/// is never required.
pub struct BigInt {
    inner: UInt,
    is_neg: bool,
}

impl BigInt {
    /// Creates a `BigInt` from a string representation of a number.
    fn parse(s: &str) -> Self {
        let is_neg = s.starts_with('-');
        let num = &s[(is_neg as usize)..];

        let inner = {
            if let Ok(uint) = U256::from_dec_str(num) {
                UInt::U256(uint)
            } else if let Ok(uint) = U512::from_dec_str(num) {
                UInt::U512(uint)
            } else if let Ok(uint) = U1024::from_dec_str(num) {
                UInt::U1024(uint)
            } else {
                let mut chunks = Vec::with_capacity(2);
                let mut h1 = num.to_string();
                let mut h2 = h1.split_off(h1.len() / 2);
                while h2.starts_with('0') {
                    // If the second half starts with a 0 it will be treated as inconsequential to
                    // the result of the parsed value, which is incorrect. So instead we should add
                    // it to the first half.
                    h1.push('0');
                    h2.remove(0);
                }
                let mut unparsed_chunks = vec![h2, h1];

                while let Some(chunk) = unparsed_chunks.pop() {
                    match U1024::from_dec_str(&chunk) {
                        Ok(parsed_chunk) => chunks.push(parsed_chunk),
                        Err(_) => {
                            let mut h1 = chunk;
                            let mut h2 = h1.split_off(h1.len() / 2);
                            while h2.starts_with('0') {
                                h1.push('0');
                                h2.remove(0);
                            }
                            unparsed_chunks.push(h2);
                            unparsed_chunks.push(h1);
                        }
                    }
                }

                UInt::Multi(chunks)
            }
        };

        BigInt { inner, is_neg }
    }
}

impl core::fmt::Display for BigInt {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if self.is_neg {
            write!(f, "-{}", self.inner.to_string())
        } else {
            write!(f, "{}", self.inner.to_string())
        }
    }
}

#[cfg(test)]
mod test {
    use super::BigInt;

    macro_rules! bigint_test {
        ($($case:ident: $str:expr)*) => {
            $(
            #[test]
            fn $case() {
                let bigint = BigInt::parse($str);

                assert_eq!(bigint.to_string(), $str);
            }
            )*
        };
    }

    bigint_test! {
        u256: "38873241744847760218045702002058062581688990428170398542849190507947196700873"
        i256: "-38873241744847760218045702002058062581688990428170398542849190507947196700873"
        u512: "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084095"
        i512: "-13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084095"
        u1024: "179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137215"
        i1024: "-179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137215"
        u2048: "32317006071311007300714876688669951960444102669715484032130345427524655138867890893197201411522913463688717960921898019494119559150490921095088152386448283120630877367300996091750197750389652106796057638384067568276792218642619756161838094338476170470581645852036305042887575891541065808607552399123930385521914333389668342420684974786564569494856176035326322058077805659331026192708460314150258592864177116725943603718461857357598351152301645904403697613233287231227125684710820209725157101726931323469678542580656697935045997268352998638215525166389437335543602135433229604645318478604952148193555853611059596230655"
        i2048: "-32317006071311007300714876688669951960444102669715484032130345427524655138867890893197201411522913463688717960921898019494119559150490921095088152386448283120630877367300996091750197750389652106796057638384067568276792218642619756161838094338476170470581645852036305042887575891541065808607552399123930385521914333389668342420684974786564569494856176035326322058077805659331026192708460314150258592864177116725943603718461857357598351152301645904403697613233287231227125684710820209725157101726931323469678542580656697935045997268352998638215525166389437335543602135433229604645318478604952148193555853611059596230655"
        u4096: "1044388881413152506691752710716624382579964249047383780384233483283953907971557456848826811934997558340890106714439262837987573438185793607263236087851365277945956976543709998340361590134383718314428070011855946226376318839397712745672334684344586617496807908705803704071284048740118609114467977783598029006686938976881787785946905630190260940599579453432823469303026696443059025015972399867714215541693835559885291486318237914434496734087811872639496475100189041349008417061675093668333850551032972088269550769983616369411933015213796825837188091833656751221318492846368125550225998300412344784862595674492194617023806505913245610825731835380087608622102834270197698202313169017678006675195485079921636419370285375124784014907159135459982790513399611551794271106831134090584272884279791554849782954323534517065223269061394905987693002122963395687782878948440616007412945674919823050571642377154816321380631045902916136926708342856440730447899971901781465763473223850267253059899795996090799469201774624817718449867455659250178329070473119433165550807568221846571746373296884912819520317457002440926616910874148385078411929804522981857338977648103126085903001302413467189726673216491511131602920781738033436090243804708340403154190336"
        i4096: "-1044388881413152506691752710716624382579964249047383780384233483283953907971557456848826811934997558340890106714439262837987573438185793607263236087851365277945956976543709998340361590134383718314428070011855946226376318839397712745672334684344586617496807908705803704071284048740118609114467977783598029006686938976881787785946905630190260940599579453432823469303026696443059025015972399867714215541693835559885291486318237914434496734087811872639496475100189041349008417061675093668333850551032972088269550769983616369411933015213796825837188091833656751221318492846368125550225998300412344784862595674492194617023806505913245610825731835380087608622102834270197698202313169017678006675195485079921636419370285375124784014907159135459982790513399611551794271106831134090584272884279791554849782954323534517065223269061394905987693002122963395687782878948440616007412945674919823050571642377154816321380631045902916136926708342856440730447899971901781465763473223850267253059899795996090799469201774624817718449867455659250178329070473119433165550807568221846571746373296884912819520317457002440926616910874148385078411929804522981857338977648103126085903001302413467189726673216491511131602920781738033436090243804708340403154190336"
    }
}
